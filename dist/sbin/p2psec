#!/bin/bash
# Robert Socha 2021/05,2021/09
# v0.25
# License: public domain

_CONFIG="/etc/default/p2psec"

_usage() {
	echo "Usage: p2psec apply|stop|keygen|generate-keys"
}

if [[ -z "$1" ]]
then
	_usage
	exit 1
fi

if [[ "$1" == "keygen" ]]
then
	echo "0x$(dd if=/dev/urandom count=32 bs=1 status=none | od -v -t x -w32 -An --endian=big | tr -d ' ')"
	exit 0
fi

if [[ "$1" == "generate-keys" ]]
then
	echo "AUTH_KEY=\"0x$(dd if=/dev/urandom count=32 bs=1 status=none | od -v -t x -w32 -An --endian=big | tr -d ' ')\""
	echo "ENC_KEY=\"0x$(dd if=/dev/urandom count=32 bs=1 status=none | od -v -t x -w32 -An --endian=big | tr -d ' ')\""
	exit 0
fi

unset PEERS
unset AUTH_KEY
unset ENC_KEY
unset AUTH_ALG
unset ENC_ALG
unset IPTABLES
unset P2P_IF

if [[ ! -f ${_CONFIG} ]]
then
	echo "Missing configuration file ${_CONFIG}"
	exit 1
fi

if [[ ! -r ${_CONFIG} ]]
then
	echo "Configuration file is not readable..."
	exit 1
fi

if [[ -z $(find "${_CONFIG}" -uid 0 -gid 0 -perm 0600 -o -perm 0400) ]]
then
	echo "Wrong owner,group or permisions for ${_CONFIG}"
	exit 1
fi

if [[ -z $PEERS ]] && [[ -s /etc/default/p2psec ]]
then
	source /etc/default/p2psec || exit 15
fi

if [[ -z $PEERS ]]
then
	echo "Missing PEERS env config..."
	exit 1
fi
if [[ -z $AUTH_KEY ]]
then
	echo "Missing AUTH_KEY env config..."
	exit 1
fi
if [[ -z $ENC_KEY ]]
then
	echo "Missing ENC_KEY env config..."
	exit 1
fi

case "${IPTABLES}" in
	1|true|yes|on)
		IPTABLES=1
		;;
	*)
		IPTABLES=0
esac

_PEERS="$PEERS"
_ATH_KEY="$AUTH_KEY"
_ENC_KEY="$ENC_KEY"
_ATH_ALG="${AUTH_ALG:-sha256}"
_ENC_ALG="${ENC_ALG:-twofish}"
_RIF="${P2P_IF:-p2psec0}"

_echo() {
	echo "$@"
}

_check_lo_addr() {
local _ip
	for _ip in $(LANG=C ip -o -4 addr show dev lo | grep -Po '(?<=(inet ))[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+')
	do
		[[ $_ip == $1 ]] && return 0
	done
	return 1
}

_check_route_if() {
	ip link show dev "${_RIF}" &>/dev/null
	return $?
}

_create_route_if() {
	ip link add name "${_RIF}" type dummy
	return $?
}

_up_route_if() {
	ip link set dev "${_RIF}" up
	return $?
}

_remove_route_if() {
	ip link delete dev "${_RIF}" type dummy
	return $?
}

_default=$(ip -4 -o route get 255.255.255.255 2>/dev/null)
if [[ -z ${_default} ]]
then
	_echo "Unable to locate default gateway..."
	exit 1
fi
_gwif=$(echo "${_default}" | grep -Po '(?<=(dev ))\S+')
_me=$(echo "${_default}" | grep -Po '(?<=(src ))[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
# Check config
_me_found=0
_me_local=""
for __peer in $_PEERS
do
	if ! [[ ${__peer} =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
	then
		_echo "Incorrect ip pair for peer: ${__peer}"
		exit 10
	fi
	__peer_ext="${__peer%:*}"
	__peer_int="${__peer#*:}"
	if [[ ${__peer_ext} == ${_me} ]]
	then
		_me_found=1
		_me_local="${__peer_int}"
	fi
done

if [[ $_me_found -eq 0 ]]
then
	_echo "Unable to locate this host ip address (${_me}) on peers list..."
	exit 15
fi

if [[ "$1" == "stop" ]] || [[ "$1" == "apply" ]]
then
	IFS=. read a1 a2 a3 a4 <<< "${_me_local}"
	for __peer in $_PEERS
	do
		__peer_ext="${__peer%:*}"
		__peer_int="${__peer#*:}"
		[[ ${__peer_ext} == ${_me} ]] && continue
		# calculate spi
		IFS=. read b1 b2 b3 b4 <<< "${__peer_int}"
		_spi=$(( ($a1^$b1) << 24 | ($a2^$b2) << 16 | ($a3^$b3) << 8 | ($a4^$b4) ))
		_spi=$(printf "0x%0x" "$_spi")
		ip xfrm policy delete src ${_me_local}/32 dst ${__peer_int}/32 dir out &>/dev/null
		ip xfrm policy delete dst ${_me_local}/32 src ${__peer_int}/32 dir in  &>/dev/null
		ip xfrm state  delete src ${_me} dst ${__peer_ext} proto esp spi ${_spi} &>/dev/null
		ip xfrm state  delete  dst ${_me} src ${__peer_ext} proto esp spi ${_spi} &>/dev/null
		ip route del ${__peer_int}/32 &>/dev/null
		if [[ ${IPTABLES} -eq 1 ]]
		then
			iptables -D INPUT -p esp -s ${__peer_ext} -d ${_me} -j ACCEPT &>/dev/null
		fi
	done

	if [[ ${IPTABLES} -eq 1 ]]
	then
		iptables -D INPUT -p esp -j DROP &>/dev/null
	fi
fi

if [[ $1 == "stop" ]] 
then
	_check_lo_addr "${_me_local}/32" && ip addr delete "${_me_local}/32" dev lo
	_check_route_if && _remove_route_if
	exit 0
fi

if [[ "$1" == "apply" ]]
then
	_echo -n "PEERS: "
	for __peer in $_PEERS
	do
		__peer_ext="${__peer%:*}"
		__peer_int="${__peer#*:}"
		if [[ ${__peer_ext} != ${_me} ]] 
		then
			_echo -n "${__peer_ext} "
		else
			_echo -n "+${__peer_ext} "
		fi
	done
	_echo
	if ! _check_route_if 
	then
		if ! _create_route_if
		then
			_echo "Unable to create virtual route interface..."
			exit 10
		fi
	fi
	_up_route_if
	if ! _check_lo_addr "${_me_local}/32"
	then
		ip addr add "${_me_local}/32" dev lo
		_echo "The local IP address ${_me_local}/32 was added to the lo interface."
	fi

	if [[ ${IPTABLES} -eq 1 ]]
	then
		iptables -I INPUT -p esp -j DROP
	fi

	for __peer in $_PEERS
	do
		__peer_ext="${__peer%:*}"
		__peer_int="${__peer#*:}"
		[[ ${__peer_ext} == ${_me} ]] && continue
		# calculate spi
		IFS=. read b1 b2 b3 b4 <<< "${__peer_int}"
		_spi=$(( ($a1^$b1) << 24 | ($a2^$b2) << 16 | ($a3^$b3) << 8 | ($a4^$b4) ))
		_spi=$(printf "0x%0x" "$_spi")
		_echo "Creating ipsec link from ${_me} to ${__peer_ext} (${_me_local}/32 -> ${__peer_int}/32) SPI: ${_spi}"	
		ip xfrm state  add src ${_me} dst ${__peer_ext} proto esp spi ${_spi} mode tunnel auth ${_ATH_ALG} ${_ATH_KEY} enc ${_ENC_ALG} ${_ENC_KEY}
		ip xfrm state  add dst ${_me} src ${__peer_ext} proto esp spi ${_spi} mode tunnel auth ${_ATH_ALG} ${_ATH_KEY} enc ${_ENC_ALG} ${_ENC_KEY}
		ip xfrm policy add src ${_me_local}/32 dst ${__peer_int}/32 dir out tmpl src ${_me} dst ${__peer_ext} proto esp spi ${_spi} mode tunnel
		ip xfrm policy add dst ${_me_local}/32 src ${__peer_int}/32 dir in  tmpl dst ${_me} src ${__peer_ext} proto esp spi ${_spi} mode tunnel
		ip route add ${__peer_int}/32 dev ${_RIF} src ${_me_local}
		if [[ ${IPTABLES} -eq 1 ]]
		then
			iptables -I INPUT -p esp -s ${__peer_ext} -d ${_me} -j ACCEPT
		fi
	done
	exit 0
fi
_usage
exit 1
